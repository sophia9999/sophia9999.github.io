# DI를 공부하다가, 내 현실을 마주했다

Spring 면접 준비를 하다 보면 빠지지 않고 등장하는 질문이 있다.  
**“DI(의존성 주입) 방식에는 어떤 것들이 있고, 각각의 장단점은 무엇인가요?”**

필드 주입, setter 주입, 생성자 주입.  
각각의 장단점은 이미 정리된 글이 넘쳐난다.  
그중에서도 많은 개발자들이 **“생성자 주입이 가장 바람직하다”**고 말한다.  
테스트가 편하고, 불변성을 보장하고, 의존 관계가 명확하다는 이유다.

그런데 문득, 내 현실을 돌아보게 됐다.  
**나는 과연 그런 주입 방식을 실제로 사용해 본 적이 있었던가?**

---

## 현실 직시: 테스트 없는 레거시, 그리고 제한된 구조

내가 일하고 있는 시스템은, 주석 기준으로만 따져도 **14년 이상 된 레거시**다.  
테스트 코드는 없다.  
기능 하나를 확인하려면 서버를 띄우고, 화면을 열어 직접 동작을 확인해야 한다.  
그런 환경에서 “테스트가 편하다”는 말은, 실감이 나지 않았다.  
그건 마치, **테스트라는 전제가 존재하는 사람들만의 언어**처럼 들렸다.

---

## DI 방식은 들어봤다. 하지만 의미가 와닿은 건 서비스 레이어였다

주입 방식에 대한 이야기는 많이 들었다.  
생성자 주입이 좋다, 테스트가 쉽다, final 키워드를 활용할 수 있다…  
하지만 그런 설명이 **직접적으로 와닿은 적은 없었다.**  
왜냐하면 내가 속한 코드는 대부분 필드 주입이었고,  
생성자 주입을 써볼 기회도 없었기 때문이다.

그런데 하나 깨달은 지점이 있었다.  
**"생성자 주입이 의미를 가지는 구간은 서비스 레이어다."**

컨트롤러나 유틸 클래스처럼  
구조가 고정되어 있거나, 의존성이 단순한 경우엔  
필드 주입이 여전히 사용되기도 하고, 크게 문제가 되지 않는 듯 보였다.  
하지만 서비스 단은 달랐다.

---

## 우리는 IoC 컨테이너에 제어권을 넘기지만,  
## 서비스 레이어에선 다시 제어 흐름을 붙잡고 싶어진다

서비스 단은 의존성이 복잡하게 얽힌다.  
여러 도메인의 리포지토리를 함께 사용하고,  
외부 API를 호출하고,  
비즈니스 흐름을 조율한다.  
거기서 발생하는 결합은,  
단순히 자동 주입(@Autowired)으로 해결되지 않는다.

**그래서 생성자 주입이 그제야 이해됐다.**  
우리는 IoC 컨테이너에게 제어권을 넘기지만,  
**서비스 레이어만큼은, 그 제어의 순서와 맥락을 명시적으로 가져가고 싶었던 것이다.**  
생성자 주입은 그 흐름을 통제하진 않지만,
그 흐름에 ‘의미’를 부여할 수 있었다.

---

## 생성자 주입은 '설계의 명시성'을 갖겠다는 태도였다

생성자 주입이 좋다는 말은, 결국 **설계의 명시성**을 갖겠다는 태도였다.  
테스트를 잘 짜기 위한 도구이기 이전에,  
**“이 의존성은 내가 책임진다”는 선언**처럼 느껴졌다.

나는 여전히 테스트 코드를 짜지 않고,  
여전히 필드 주입으로 이루어진 프로젝트에서 일하고 있다.  
하지만 그 환경 속에서도,  
**서비스 레이어만큼은 다르게 하고 싶다는 생각이 들었다.**

그곳은 결국,  
**의존성이 얽히고 책임이 분기되며, 흐름을 통제하고 싶은 곳**이기 때문이다.

---

## 마지막으로 내가 그리고 있는 그림

언젠가 내가 설계할 수 있는 서비스가 생긴다면,  
그 첫 줄은 이렇게 시작될 것이다:

```java
@RequiredArgsConstructor
@Service
public class MyService {
    private final A a;
}

@Service
public class MyService {
    private final A a;

    @Autowired  // Spring 4.3 이후엔 생략 가능
    public MyService(A a) {
        this.a = a;
    }
}
```

이건 단지 생성자 주입 예제가 아니다.
이건 내가 의존성을 이해하고,
흐름을 설계하고,
설계에 책임을 지겠다는 다짐의 한 줄이다.

